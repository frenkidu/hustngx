<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
    <title>sequential subrequests</title>
    <link type="text/css" rel="stylesheet" href="../assets/css/github-markdown.css">
    <link type="text/css" rel="stylesheet" href="../assets/css/pilcrow.css">
    <link type="text/css" rel="stylesheet" href="../assets/css/hljs-github.min.css"/>
  </head>
  <body>
    <article class="markdown-body"><h2 id="sequential-subrequests"><a class="header-link" href="#sequential-subrequests"></a>sequential subrequests</h2>
<p>本节重点讲解 <code>sequential subrequests</code> （多轮串行子请求）相关的技术原理。</p>
<h3 id="-"><a class="header-link" href="#-"></a>节点选择</h3>
<p><code>sequential subrequests</code> 是 nginx http 模块开发中难度最大的技术点之一。正确进行 <code>sequential subrequests</code> 编程的关键，是将 <code>backend</code> 节点选择的控制权从 nginx 内核转移到客户端 （nginx 扩展模块），这样你可以自己决定将子请求转发给哪一个后端机器。 <code>lib_hustngx</code> 中的 <a href="lib_hustngx/http_module.html"><code>ngx_http_peer_selector_module</code></a> 可以完美地解决此问题。</p>
<h3 id="--1"><a class="header-link" href="#--1"></a>状态机</h3>
<p>另外一个关键点是要理解 <code>subrequest</code> 的状态机模型。每一个子请求发出去之后，nginx 将回到主循环中，等待下一个事件的触发。因此所有跨越子请求的上下文，都需要由你自己保存下来（<code>hustngx</code>生成的代码中以 <code>ctx</code> 作为类型定义的结尾）。</p>
<p>此外，<code>sequential subrequests</code> 的投递方法 <strong>并非</strong> 用我们所熟悉的 for 循环方式实现：</p>
<pre class="hljs"><code><span class="hljs-keyword">for</span> (subrequest <span class="hljs-keyword">in</span> subrequests):
    <span class="hljs-comment"># do your business</span></code></pre><p>而是用如下的状态机编程的方式实现：</p>
<pre class="hljs"><code>ngx_int_t hustmq_ha_autost_handler(ngx_str_t * backend_uri, ngx_http_request_t *r)
{
    <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span>
    hustmq_ha_autost_ctx_t * ctx = ngx_http_get_addon_module_ctx(r);
    <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>ctx)
    {
        <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span>
        hustmq_ha_autost_ctx_t * ctx = ngx_palloc(r<span class="hljs-subst">-&gt;</span>pool, sizeof(hustmq_ha_autost_ctx_t));
        <span class="hljs-keyword">if</span> (<span class="hljs-subst">!</span>ctx)
        {
            <span class="hljs-keyword">return</span> NGX_ERR<span class="hljs-subst">OR</span>;
        }
        memset(ctx, <span class="hljs-number">0</span>, sizeof(hustmq_ha_autost_ctx_t));
        ngx_http_set_addon_module_ctx(r, ctx);

        <span class="hljs-attribute">...</span><span class="hljs-attribute">...</span>

        ctx<span class="hljs-subst">-&gt;</span>peer = ngx_http_first_peer(peers<span class="hljs-subst">-&gt;</span>peer);
        <span class="hljs-keyword">return</span> ngx_http_gen_subrequest(backend_uri, r, ctx<span class="hljs-subst">-&gt;</span>peer,
                <span class="hljs-subst">&amp;</span>ctx<span class="hljs-subst">-&gt;</span>base, ngx_http_post_subrequest_handler);
    }

    ctx<span class="hljs-subst">-&gt;</span>peer = ngx_http_next_peer(ctx<span class="hljs-subst">-&gt;</span>peer);
    <span class="hljs-keyword">if</span> (ctx<span class="hljs-subst">-&gt;</span>peer)
    {
        <span class="hljs-keyword">return</span> ngx_http_run_subrequest(r, <span class="hljs-subst">&amp;</span>ctx<span class="hljs-subst">-&gt;</span>base, ctx<span class="hljs-subst">-&gt;</span>peer);
    }
    <span class="hljs-attribute">...</span>

    <span class="hljs-keyword">return</span> ngx_http_send_response_imp(r<span class="hljs-subst">-&gt;</span>headers_out<span class="hljs-built_in">.</span>status, <span class="hljs-built_in">NULL</span>, r);
}</code></pre><p>如果你是第一次写 <code>sequential subrequests</code> 的程序，你很难理解为什么上面的代码有三处 <code>return</code>，因为这三处 <code>return</code> 前后的条件分支看上去根本无法全部执行！</p>
<p>这就需要理解 <code>sequential subrequests</code> 的状态机模型。</p>
<p>以上述代码为例子，当调用 <code>ngx_http_gen_subrequest</code> 产生子请求之后，程序的流程就转移到 nginx 主循环之中了（nginx 是全异步，事件驱动的，不能包含任何阻塞和耗时的调用）。<br>当子请求完成之后，nginx 会调用 <code>ngx_http_post_subrequest_handler</code>（该函数定义在 <a href="lib_hustngx/http_module.html"><code>ngx_http_utils_module</code></a> 中），并最终调用 <code>hustmq_ha_autost_handler</code>，也就是入口函数。<br><strong>因此，每一轮子请求结束之后，nginx 都会再次调用入口函数 <code>hustmq_ha_autost_handler</code>，这正是实现 <code>sequential subrequests</code> 的关键</strong>。</p>
<p>接下来的问题就是，如何区分当前 <code>hustmq_ha_autost_handler</code> 是处于第一个子请求开始前，还是第二个，还是最后一个？<br>请留意代码中的如下两行：</p>
<pre class="hljs"><code><span class="hljs-keyword">if</span> <span class="hljs-comment">(!ctx)</span>
...
<span class="hljs-keyword">if</span> <span class="hljs-comment">(ctx-&gt;peer)</span></code></pre><p>这两行就是状态机编程的一种典型的实现。<br><strong>对于每一个新的 <code>ngx_http_request_t</code> 对象</strong>，当 nginx 第一次调用 <code>hustmq_ha_autost_handler</code>的时候，<code>ctx</code> 对象是不存在的，因此其值为空， <strong>利用这个特点可以区分当前是否是第一次调用 <code>hustmq_ha_autost_handler</code>（第一个子请求开始前）</strong> 。<br>之后的子请求，就需要在 <code>ctx</code> 里面定义字段，通过该字段的值来判定当前处于什么阶段。上面的代码以下一个 <code>backend</code> 节点是否存在作为判定标志。当 <code>ctx-&gt;peer</code> 为空的时候，说明已经遍历完毕，可以将处理结果返回给客户端了， <code>sequential subrequests</code> 将终止在这一轮调用。</p>
<p>因此，基于状态机编程的方式本质上是将原本串行执行的 <code>for (i = 0; i &lt; N; ++i)</code> 拆分成了三段：</p>
<ul class="list">
<li><p>第一段，初始化 <code>ctx</code>（等价于 i = 0）</p>
</li>
<li><p>第二段，更新 <code>ctx-&gt;peer</code> 为下一个节点（等价于 ++i）</p>
</li>
<li><p>第三段，如果遍历完毕，返回给客户端结果（等价于 i &lt; N）</p>
</li>
</ul>
<h3 id="--2"><a class="header-link" href="#--2"></a>引用计数</h3>
<p>进行 <code>sequential subrequests</code> 编程遇到的另外一个棘手的问题是对资源的管理（主要是 <code>ngx_http_request_t</code> 对象的回收）。<br>nginx 内部是通过引用计数来进行管理的。由于 nginx 对于引用计数的操作分散在很多个模块，因此必须格外留意 <code>r-&gt;main-&gt;count</code> 的变化。<br>如果在进行调试（例如，在 <code>hustmq_ha_autost_handler</code> 入口处下断点，每一次调用进来 <code>r-&gt;main-&gt;count</code> 都应该是同一个值）的时候发现这个值只增不减，或者只减不增，那么程序一定有问题。 <strong>这将使得 <code>ngx_http_request_t</code> 对象永远没有机会得到回收，从而导致严重的资源泄露</strong> 。</p>
<p><strong>关于引用计数， <code>hustngx</code> 对于生成的代码中全部做了正确的处理，因此大部分引用计数的问题你都不会在该框架生成的代码中遇到。</strong></p>
<p>如果你没有采用 <code>hustngx</code> 生成代码，请自行管理好 <code>r-&gt;main-&gt;count</code> 的变化，否则你写出来的模块将是不可用的。</p>
<p>即使你采用了 <code>hustngx</code> 生成代码，如果最终的业务逻辑和原始的代码有了非常大的出入（毕竟 <code>hustngx</code> 无法帮你生成极其特殊的业务逻辑），也请留意 <code>r-&gt;main-&gt;count</code> 的变化， <strong>它的值是你的程序是否可用的关键</strong> 。</p>
<p><a href="./index.html">上一级</a></p>
<p><a href="../index.html">根目录</a></p>
    </article>
  </body>
</html>
