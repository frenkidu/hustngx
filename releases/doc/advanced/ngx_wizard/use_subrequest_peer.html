<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, minimal-ui">
    <title>&#x60;use_subrequest_peer&#x60;</title>
    <link type="text/css" rel="stylesheet" href="../../assets/css/github-markdown.css">
    <link type="text/css" rel="stylesheet" href="../../assets/css/pilcrow.css">
    <link type="text/css" rel="stylesheet" href="../../assets/css/hljs-github.min.css"/>
  </head>
  <body>
    <article class="markdown-body"><h2 id="-use_subrequest_peer-"><a class="header-link" href="#-use_subrequest_peer-"></a><code>use_subrequest_peer</code></h2>
<p><strong>类型:</strong> <code>bool</code></p>
<p><strong>值:</strong> <code>true | false</code></p>
<p><strong>属性:</strong> 可选</p>
<p><strong>父节点:</strong> <a href="./subrequests.html">subrequests</a></p>
<p>是否使用 <code>ngx_http_subrequest_peer_t</code> 所定义的类型来缓存 <code>subrequest</code> 节点。</p>
<p><strong>如果 <a href="./use_round_robin.html"><code>use_round_robin</code></a> 被配置成 <code>true</code>，则该字段失效。</strong></p>
<p>如果配置为 <code>false</code> , 或者忽略该字段，则使用 nginx 内置的 <code>ngx_http_upstream_rr_peer_t</code> 作为节点的缓存类型，例如：</p>
<pre class="hljs"><code><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>
{
    <span class="hljs-keyword">ngx_http_subrequest_ctx_t</span> base;
    <span class="hljs-keyword">ngx_http_upstream_rr_peer_t</span> * peer;
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add your fields here</span>
} <span class="hljs-keyword">hustmqha_autost_ctx_t</span>;</code></pre><p>如果配置为 <code>true</code> ，则使用 <code>lib_hustngx</code> 所定义的 <code>ngx_http_subrequest_peer_t</code> 作为节点的缓存类型，例如：</p>
<pre class="hljs"><code><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span>
{
    <span class="hljs-keyword">ngx_http_subrequest_ctx_t</span> base;
    <span class="hljs-keyword">ngx_http_subrequest_peer_t</span> * subrequest_peer;
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> add your fields here</span>
} <span class="hljs-keyword">hustmqha_pub_ctx_t</span>;</code></pre><p>nginx 在读取配置文件的 <code>upstream</code> 字段之后，会将 <code>backend</code> 机器列表解析成内置的链表类型，也就是 <code>ngx_http_upstream_rr_peer_t</code> ，其顺序是固定的。</p>
<p>因此，在进行 <code>sequential subrequests</code> 的时候：</p>
<ul class="list">
<li><strong>如果你只需要以固定的顺序来遍历 <code>backend</code> 节点列表，则可以忽略该字段</strong>，或者将之设置成 <code>false</code>；</li>
<li><strong>如果你遍历 <code>backend</code> 节点列表的顺序是不确定的，需要定制，则需要将该字段设置成 <code>true</code></strong> 。</li>
</ul>
<p>更进一步，如果你将该字段设置成 <code>true</code>, 则需要在进行 <code>sequential subrequests</code> 之前构建链表，例如：</p>
<pre class="hljs"><code><span class="hljs-keyword">static</span> <span class="hljs-keyword">ngx_int_t</span> __first_pub_handler(<span class="hljs-keyword">ngx_str_t</span> * backend_uri, <span class="hljs-keyword">ngx_http_request_t</span> *r)
{
    ......
    <span class="hljs-keyword">ngx_http_subrequest_peer_t</span> * peer = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> you can initialize the peer list here</span>
    <span class="hljs-comment">// peer = ngx_http_init_peer_list(r-&gt;pool, ngx_http_get_backends());</span>
    <span class="hljs-keyword">if</span> (!peer)
    {
        <span class="hljs-keyword">return</span> NGX_ERROR;
    }

    <span class="hljs-keyword">hustmqha_pub_ctx_t</span> * ctx = ngx_palloc(r-&gt;pool, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">hustmqha_pub_ctx_t</span>));
    <span class="hljs-keyword">if</span> (!ctx)
    {
        <span class="hljs-keyword">return</span> NGX_ERROR;
    }
    <span class="hljs-built_in">memset</span>(ctx, <span class="hljs-number">0</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">hustmqha_pub_ctx_t</span>));
    ngx_http_set_addon_module_ctx(r, ctx);
    <span class="hljs-comment">// <span class="hljs-doctag">TODO:</span> you can initialize ctx here</span>

    ctx-&gt;subrequest_peer = ngx_http_get_first_peer(peer);

    ......
}</code></pre><p>请注意被注释的一行代码：</p>
<pre class="hljs"><code>// peer = ngx_http_init_peer_list<span class="hljs-list">(<span class="hljs-keyword">r-&gt;pool</span>, ngx_http_get_backends<span class="hljs-list">()</span>)</span><span class="hljs-comment">;</span></code></pre><p><code>ngx_http_init_peer_list</code> 是 <code>lib_hustngx</code> 所提供的函数，以默认的方式构建链表（其节点顺序和 <code>ngx_http_upstream_rr_peer_t</code> 所存储的链表顺序是一样的）。你可以参考这个函数的实现来自行决定如何构建链表。</p>
<p><strong>如果忽略该字段，则使用 nginx 内置的 <code>ngx_http_upstream_rr_peer_t</code> 作为节点的缓存类型，以固定的顺序来遍历 <code>backend</code> 机器列表</strong>。</p>
<p><a href="../ngx_wizard.html">上一级</a></p>
<p><a href="../../index.html">根目录</a></p>
    </article>
  </body>
</html>
